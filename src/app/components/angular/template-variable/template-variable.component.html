<div>
  <h1 style="font-size: 3rem;">TEMPLATE VARIABLE AND VIEWCHILD/VIEWCHILDREN</h1>
  <br>
  <p>Khi cần trỏ đến một phần tử (HTMLElement, component, directive) ở trong template và thao tác trực tiếp lên nó.</p>
  <p>Tạo ra một "variable" ở trong template và sử dụng nó.</p>
  <br>

  <!-- Parent interacts with child via local variable -->
  <span style="font-size: 2rem;" class="pb-0">Parent interacts with child via local variable</span>
  <div class="border-b1"></div>
  <br>
  <p>Giả sử chúng ta có một ToggleComponent được đặt trong AppComponent</p>
  <p>Thay vì click vào ToggleComponent để thay đổi trạng thái của nó thì chúng ta sẽ dùng 1 button ở parent
    (Appcomponent):</p>
  <br>
  <pre>
     <code>{{text1}}</code>
   </pre>
  <br>
  <p>Làm thế nào để chúng ta có thể gọi được method toggle() của ToggleComponent?</p>
  <p>Chúng ta có thể sử dụng Template variable với cú pháp</p>
  <br>
  <pre>
     <code>{{text2}}</code>
   </pre>
  <br>
  <p>Cú pháp của Template variable chính là sử dụng #varName và bạn có thể tạo nhiều variable trong template.</p>
  <button type="button" class="btn btn-primary" (click)="toggleComp.toggle()">Toggle</button>
  <app-toggle #toggleComp></app-toggle>
  <br>

  <!-- Template variable sẽ là instance của class nào? -->
  <span style="font-size: 2rem;" class="pb-0">Template variable sẽ là instance của class nào?</span>
  <div class="border-b1"></div>
  <br>
  <p>Thông thường, một element trong template của một component sẽ có thể là một HTMLElement, hoặc một Component. Nhưng
    có những trường hợp sẽ có nhiều Directives cùng được đặt vào một element, vậy Template variable sẽ cho chúng ta một
    object thuộc kiểu nào?</p>
  <p>Mặc định Template variable mà không có expression #varName sẽ cố gắng lấy về một object, trong đó đối với
    HTMLElement thì object đó chính là HTMLElement, còn với Component thì chính là instance của Component đó</p>
  <p>Trong một số trường hợp bạn cần lấy chính xác một instance của một directive/component nào đó thì bạn sẽ cần sử
    dụng cú pháp #varName="exportAsOfDirectiveOrComponent", ví dụ như khi làm việc với FormsModule và ngModel, bạn có
    thể nhìn thấy cú pháp sau:</p>
  <br>
  <pre>
      <code>{{text3}}</code>
    </pre>
  <br>
  <p>Làm thế nào để chúng ta có thể gọi được method toggle() của ToggleComponent?</p>
  <p>Chúng ta có thể sử dụng Template variable với cú pháp</p>
  <br>
  <pre>
      <code>{{text2}}</code>
    </pre>
  <br>
  <p>Cú pháp của Template variable chính là sử dụng #varName và bạn có thể tạo nhiều variable trong template.</p>
  <button type="button" class="btn btn-primary" (click)="toggleComp.toggle()">Toggle</button>
  <app-toggle #toggleComp></app-toggle>
  <br>

  <!-- Parent class with ViewChild -->
  <span style="font-size: 2rem;" class="pb-0">Parent class with ViewChild</span>
  <div class="border-b1"></div>
  <br>
  <p>Khi chúng ta muốn gọi đến Template variable ở trong class của một component thì sao?</p>
  <p>Lúc này chúng ta có thể query một Template variable ở trong Component như sau:</p>
  <br>
  <pre>
       <code>{{text4}}</code>
     </pre>
  <br>
  <p>Nếu sử dụng ViewChild cho một HTMLElement thì chúng ta sẽ nhận được một ElementRef thay vì một HTMLElement như sử
    dung ở trong template</p>
  <br>
  <pre>
       <code>{{text5}}</code>
     </pre>
  <br>
  <p><strong>Lưu ý</strong> Ngoài những thiết lập mặc định ở trên cho ViewChild, chúng ta còn có thể truyền vào config
    cho nó với các thông số chi tiết trong link sau:</p>
  <a href="https://angular.io/api/core/ViewChild">https://angular.io/api/core/ViewChild</a>
  <p>Cú pháp có thể sử dụng như sau</p>
  <br>
  <pre>
       <code>{{text6}}</code>
     </pre>
  <p>opts.static nếu selector không nằm trong if/else hay trong một structure directive nào thì chúng ta có thể gọi nó
    là static: false, tức là nó không thay đổi trong suốt thời gian sống của component.Lúc này Angular sẽ chạy phần
    resolve query result trước khi chạy Change Detection nên chúng ta có thể truy cập nó ngOnInit như ở trên. nêu
    static:false (giá trị mặc định) thì tiến trình trên sẽ chạy sau khi chạy Change Detection nên bạn không thể dùng nó
    ở ngOnInit mà phải chạy ở ngAfterViewInit</p>
  <br>

  <!-- Parent class with ViewChildren -->
  <span style="font-size: 2rem;" class="pb-0">Parent class with ViewChildren</span>
  <div class="border-b1"></div>
  <br>
  <p>Khi muốn query danh sách các element thì có thể dùng VirewChildren.</p>
  <p>ViewChildren sẽ trả về một QueryList trước khi ngAfterViewInit được chạy. Nó sẽ chứa một số property/method để
    chúng ta có thể listen vào một số event (Observable)</p>
  <br>
  <pre>
      <code>{{text7}}</code>
    </pre>
  <br>
</div>